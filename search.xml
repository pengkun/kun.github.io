<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xcode10适配]]></title>
    <url>%2F2018%2F10%2F24%2Fxcode10%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[最近从苹果开发者网站下载了最新的xcode10并同时安装了9和10版本，我们项目是用swift语言开发，所以面对swift4.2版本报了不少错误 1. 第三方库需要升级修改升级第三方的版本号 检查当前编译器环境xcodebuild -version 切换使用Xcode10的编译器，确保是Xcode10sudo xcode-select -switch /Applications/Xcode10.app 重新编译第三方库carthage update –platform iOS 2. 报info.plist文件重复的错误解决方法1. 删除掉第三方库当中的infp.plist 解决方法2. Xcode - Project Setting - Build System - Legacy Build System 3. 报缺少动态库libstdc++.*的错误libstdc++.tbd和libstdc++6.0.9.tbd在xcode10中已经被废弃 解决方法1. 删除本地ibstdc++.tbd和libstdc++6.0.9.tbd，并且升级第三方库 解决方法2. 将xcode9中的ibstdc++.tbd和libstdc++6.0.9.tbd拷贝到xcode10]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Carthage</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用crontab给scrapy的爬虫程序添加定时任务]]></title>
    <url>%2F2018%2F09%2F21%2Fcrontab%2F</url>
    <content type="text"><![CDATA[1. 编写执行任务的cron.sh,并输出日志12345678#! /bin/shexport PATH=$PATH:/Library/Frameworks/Python.framework/Versions/3.6/bin# 爬虫文件地址cd /Users/xxx/Documents/Code/Spider/News/newsnohup scrapy crawl news --nolog &gt;&gt; news.log 2&gt;&amp;1 &amp; 2. 添加定时任务123sudo crontab -e */1 * * * * sh /Users/pengkun/Documents/SourceCode/Spider/cron.sh 1234567每五分钟执行 */5 * * * *每小时执行 0 * * * *每2小时执行 0 */2 * * *每天执行 0 0 * * *每周执行 0 0 * * 0每月执行 0 0 1 * *每年执行 0 0 1 1 * 查看定时任务sudo crontab -l 3. 遇到的问题 代码是在PyCharm IDE里编写的，依赖的库之前用pip3 install过一次，在PyCharm里也install一次，直接命令行运行scrapy是没有问题，当用crontab开启定时任务时，一直报错 module XX 找不到，具体原因不太清楚，把所有用pip3 安装过的插件移除掉重新安装 就没有问题了]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用scrapy爬虫]]></title>
    <url>%2F2018%2F08%2F21%2Fpython-scrapy%2F</url>
    <content type="text"><![CDATA[1、安装wheel pip install wheel 2、安装lxml https://pypi.python.org/pypi/lxml/4.1.0 3、安装pyopenssl https://pypi.python.org/pypi/pyOpenSSL/17.5.0 4、安装Twisted https://www.lfd.uci.edu/~gohlke/pythonlibs/ 5、安装pywin32 https://sourceforge.net/projects/pywin32/files/ 6、安装scrapy pip install scrapy 创建工程 1scrapy startproject Spider 创建爬虫程序 12cd Spiderscrapy genspider meiju meijutt.com 执行爬虫 1scrapy crawl meiju --nolog post请求注释 start_urls，重写start_requests方法，request的callback回调到parse方法，这样我们就可以继续解析出我们想要的内容了 123456789def start_requests(self): yield scrapy.FormRequest( url='https://www.chainfor.com/home/list/news/data.do?', formdata=&#123; 'pageNo': '1', 'device_type': '0' &#125;, callback=self.parse ) 新闻先抓取列表链接，再抓取内容如果抓取新闻网站的时候，我们总是会遇到第一页面总是列表，还要再通过列表的链接抓取内容。我们只需要在parse函数里通过抓取的链接进行request请求，同样适用callback 指向自定义回调函数就可以。 12345678910111213141516171819202122def parse(self, response): list = [新闻列表链接] for i in range(len(list)): url = list[i] scrapy.Request(url, callback=self.parse_dir_contents) passdef parse_dir_contents(self, response): item = Item() item["name"] = response.xpath("//div[@class='m-infor rt']/div[@class='m-i-article']/h1/text()").extract()[0].strip() item["time"] = self.validTime[idx] item["img"] = self.validImgs[idx] content = response.xpath("//div[@class='m-infor rt']/div[@class='m-i-article']/div[@class='m-i-bd']/*") newsContent = '' for p in content: temp = etree.tostring(p, encoding='utf-8').decode('utf-8') newsContent += temp item["content"] = newsContent yield item pass 获取内容标签里的所有标签 xpath语句最后 ‘/*’，标签对象转字符串时，需要解码 网上查得给自定义回调函数添加其他参数时，代码： scrapy.Request(url, callback=lambda response, idx=i: self.parse_dir_contents(response, idx)) def parse_dir_contents(self, response, idx):]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑步轨迹回放]]></title>
    <url>%2F2017%2F12%2F05%2F%E8%B7%91%E6%AD%A5%E8%BD%A8%E8%BF%B9%E5%9B%9E%E6%94%BE%2F</url>
    <content type="text"><![CDATA[高德地图跑步轨迹展示的代码在高德官方的3D地图示例中RunningLineViewController类中已经有很好的示例代码，就不再赘述了 下载AMap_iOS_Demo。这篇主要记录下实现轨迹回放的功能，当然这个方法对于所有地图的轨迹回放都是可用的。 实现回放准备条件： 坐标数组、坐标对应的颜色数组 渐变线 动画 坐标转换，计算path-var coordinateArray: [CLLocationCoordinate2D] = [] // 跑步记录的坐标集合coordinateArray 转换成视图上的坐标用于创建layer轨迹的CGMutablePath对象 1234567891011fileprivate func pointsForCoordinates() -&gt;[CGPoint] &#123; var points: [CGPoint] = [] for coordinate in self.coordinateArray &#123; guard let map_view = self.mapView else &#123; return [] &#125; let point = map_view.convert(coordinate, toPointTo: map_view) points.append(point) &#125; return points&#125;let path = CGMutablePath()path.addLines(between: points) 渐变线-自定义CustomGradientLayer，重写draw(in ctx: CGContext)方法。这里要用到Quartz2D的知识点，我在简书里找到了关于Quartz2D讲解可以学习一下。这里用到了路径、颜色与颜色空间、渐变相关技术。颜色的处理方式采用的是高德demo里面的算法，只是修改了一下偏冷色和偏暖色的值。(Swift中苹果对CGMutablePath进行了重构，CGMutablePath被定义为了类, 内存这一块就不用我们手动管理了，👍👍👍) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func add(points: [CGPoint], colors: [UIColor]) &#123; self._points = points self._colors = colors&#125;override func draw(in ctx: CGContext) &#123; var pcolor: UIColor? var ccolor: UIColor? for i in 0..&lt;self._points.count &#123; let point: CGPoint = self._points[i] let path: CGMutablePath = CGMutablePath() ccolor = self._colors[i] if i == 0 &#123; path.move(to: CGPoint(x: point.x, y: point.y), transform: .identity) &#125; else &#123; let prevPoint: CGPoint = self._points[i - 1] path.addLine(to: CGPoint(x: point.x, y: point.y), transform: .identity) var pc_r: CGFloat = 0 var pc_g: CGFloat = 0 var pc_b: CGFloat = 0 var pc_a: CGFloat = 0 var cc_r: CGFloat = 0 var cc_g: CGFloat = 0 var cc_b: CGFloat = 0 var cc_a: CGFloat = 0 pcolor?.getRed(&amp;pc_r, green: &amp;pc_g, blue: &amp;pc_b, alpha: &amp;pc_a) ccolor?.getRed(&amp;cc_r, green: &amp;cc_g, blue: &amp;cc_b, alpha: &amp;cc_a) let gradientColors: [CGFloat] = [pc_r, pc_g, pc_b, pc_a, cc_r, cc_g, cc_b, cc_a] let gradientLocation: [CGFloat] = [0, 1] ctx.saveGState() let lineWidth: CGFloat = ctx.convertToUserSpace(CGSize(width: 5, height: 5)).width let pathToFill: CGPath = path.copy(strokingWithWidth: lineWidth, lineCap: .round, lineJoin: .round, miterLimit: 10, transform: .identity) ctx.addPath(pathToFill) ctx.clip() let colorSpace: CGColorSpace = CGColorSpaceCreateDeviceRGB() if let gradient = CGGradient(colorSpace: colorSpace, colorComponents: gradientColors, locations: gradientLocation, count: 2) &#123; let gradientStart: CGPoint = prevPoint let gradientEnd: CGPoint = point ctx.drawLinearGradient(gradient, start: gradientStart, end: gradientEnd, options: .drawsAfterEndLocation) &#125; ctx.restoreGState() &#125; pcolor = ccolor &#125;&#125; 在gradientLayer调用func add(points: [CGPoint], colors: [UIColor]) 函数后调用自身的setNeedsDisplay()方法重绘。我们还需要在Replaying中给layer添加一个蒙板mask(这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。mask图层定义了父图层的部分可见区域) 12345678fileprivate func initShapeLayer() &#123; self.shapeLayer.lineWidth = 5 self.shapeLayer.strokeColor = UIColor.clear.cgColor self.shapeLayer.fillColor = UIColor.clear.cgColor self.shapeLayer.lineJoin = kCALineCapRound&#125;self.shapeLayer.path = pathself.gradientLayer.mask = self.shapeLayer ok，渐变线出来了 动画动画12345678910let shapeLayerAnimation = self.constructShapeLayerAnimation()self.shapeLayer.add(shapeLayerAnimation, forKey: "shape")fileprivate func constructShapeLayerAnimation() -&gt; CAAnimation &#123; let annimation = CABasicAnimation(keyPath: "strokeEnd") annimation.duration = self.duration annimation.fromValue = 0.0 annimation.toValue = 1.0 return annimation&#125; 下载]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Running</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑步过程中播报跑步数据，实现长时间后台保活]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%97%B6%E9%97%B4%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%B4%BB%EF%BC%8C%E8%B7%91%E6%AD%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%92%AD%E6%8A%A5%E8%B7%91%E6%AD%A5%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[编写跑步app的时候音频播放总是面临着三个问题： 如何保证app长时间后台运行 如何在播报语音(几十个mp3文件)时保障连贯性 利用AudioSession如何处理好与其他同类型app播放的冲突 当时经过对竞品app的研究发现，实现长时间后台运行采用其中一种方式：持续播放无声音乐对于第二个问题，我们一直在试错： 第一种方式将即将播放的语音文件名存入数组中，轮询播放数组里文件 第二种方式将即将播放的语音提前初始化AudioPlayer缓存到内存中，轮询播放 （这两种方式呢都没有保障播放的连贯性，而且如果用户手机里安装了同样采用此种做法的app的话，AudioSession设置比较复杂，而且播放中出现‘抢夺播放’导致播放卡顿的问题肯定会存在。） 第三种方式利用AVMutableComposition合并所有即将播放的文件成一个文件，单独播放这一个文件既解决连贯性也解决了抢夺播放的问题 程序保活AudioSession的设置： 播放无音音乐实现程序后台持续运行，category: AVAudioSessionCategoryPlayback。 需要考虑不要影响其他app的音频播放，比如音乐类软件, options: . mixWithOthers(混响)调用AudioPlayer播放前先设置AudioSession 123456do &#123; try self.audioSession.setCategory(AVAudioSessionCategoryPlayback, with: .mixWithOthers) try self.audioSession.setActive(true)&#125; catch let error &#123; debugPrint("\(type(of:self)):\(error)")&#125; 1. 场景123456// 背景音乐enum AudioPlayScene &#123; case normal // 前台播放，后台不播放，为了用户在使用时可以任意修改音量 case none // 前后台都不播放 case run // 前后台都需要播放，用于跑步过程中&#125; 根据自己的需求设置 AudioManager.shared.audioPlayScene 2. 启动保活实现保活需要在AppDelegate中实现必要的两个回调函数 123456789101112func applicationDidEnterBackground(_ application: UIApplication) &#123; // 不在跑步页面才需要关闭 if AudioManager.shared.audioPlayScene != .run &#123; AudioManager.shared.openBackgroundAudioAutoPlay = false &#125;&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; AudioManager.shared.openBackgroundAudioAutoPlay = true&#125; 播报AudioModel 对数据的处理和封装MergeAudioTool 对AudioModel的数据进行合并 123456func play() &#123; var audioText = [[String: [String]]]() audioText.append(["altitude": ["3","2","1","relax","3","2","1","relax"]]) guard let audioModel = AudioModel(res: audioText) else&#123;return&#125; AudioManager.shared.playWithModel(res: audioModel)&#125; Demo]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Running</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS整体竖屏,个别页面横屏遇到的坑及解决办法]]></title>
    <url>%2F2017%2F11%2F15%2FiOS%E6%95%B4%E4%BD%93%E7%AB%96%E5%B1%8F%2C%E4%B8%AA%E5%88%AB%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%B1%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[iOS竖屏状态下present一个横屏的viewController(继承BaseViewController)出现bug，每次app第一次启动后，会出现如图1中的现象，本应该横屏全屏的界面，结果成了竖屏只有上半边的情况，下半边全黑，再次进入这个页面就不会再出现。 图1 这时我在【General】【Device Orientation】中只选择了【Portrait】 在需要横屏的ViewController中添加代码： 1234567891011override var shouldAutorotate: Bool { return false }override var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .landscapeRight } override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation { return .landscapeRight } 解决办法在【General】【Device Orientation】中选择了【Portrait】和【Landscape Right】，只在AppDelegate中设置 123456789var allowRotation: Bool = false //是否允许转向func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask { if self.allowRotation { return .landscapeRight } else { return .portrait } } 然后在需要设置横屏的Controller 的 viewDidLoad 函数中设置 123if let appDelegate = UIApplication.shared.delegate as? AppDelegate { appDelegate.allowRotation = true } 在点击返回按钮时重新设置上面的值 123if let appDelegate = UIApplication.shared.delegate as? AppDelegate { appDelegate.allowRotation = false }]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iWatch-page]]></title>
    <url>%2F2017%2F09%2F30%2FiWatch-page%2F</url>
    <content type="text"><![CDATA[今天整理一下在 Apple Watch 上实现 Page 和 圆形进度条两种效果，刚开始做的时候也很头大，也没见有多少人写 特别是 关于 圆形进度条效果 的博客。其实这两种效果实现起来超乎想象的简单。 Page实现Page效果有两种方式： 第一种 在storyboard上连线 第一个controller连第二个controller选择next page第二个controller连第三个controller选择next page他们之间的返回，SB也已经为我们做好了 第二种 使用代码ExtensionDelegate func applicationDidFinishLaunching() { // Perform any final initialization of your application. WKInterfaceController.reloadRootControllers(withNames: [&quot;Controller1&quot;, &quot;Controller2&quot;, &quot;Controller3&quot;], contexts: nil) } `&lt;/pre&gt; 如果说我想让Page中的第一个controller的按钮操作影响第二个controller，我目前找到的方法是 notification ## [](#圆形进度条 &quot;圆形进度条&quot;)圆形进度条 当时为了这个东西也是翻遍的了 度娘 后来还是在stackflow上找到一个答案。 `WKImageAnimatable` 协议的有一个函数： &lt;pre&gt;`// Play a subset of images for a certain number of times. 0 means repeat until stop. public func startAnimatingWithImages(in imageRange: NSRange, duration: TimeInterval, repeatCount: Int) 类似 UIImageView 的 startAnimating() 方法，看到这里明眼人就明白了，watch上实现的进度条是一张图片，进度的改变的过程就是一组帧动画你要做的就是算好执行到哪一帧 实现进度条用到的图片已经有大大们制作好了工具传送门]]></content>
      <tags>
        <tag>Apple Watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift与Object-C混编创建Framework，并引用cocopods（OC代码库）]]></title>
    <url>%2F2017%2F07%2F31%2FSwift%E4%B8%8EObject-C%E6%B7%B7%E7%BC%96%E5%88%9B%E5%BB%BAFramework%EF%BC%8C%E5%B9%B6%E5%BC%95%E7%94%A8cocopods%EF%BC%88OC%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自己在创建Framework的过程中踩了很多坑，特别是我们有一部分关键代码是 C++ 写的而且还需要引用第三方 Object-C 库就更坑了，把跳坑的方法写在这里。 创建Framework-Xcode-&gt;File-&gt;New-&gt;Project-&gt;Cocoa Touch Framework我这里命名 TestUIKit Swift创建 Framework 文件目录要求代码放进Sources文件夹，我们需要修改一下文件目录，将项目中的 TestUIKit实体文件夹改名成 Sources，前后对比图： 与此同时我们还需要在项目右侧的TARGETS-&gt;Build Setting里面修改Info.plist路径地址Sources/Info.plist 创建 Object-C 类-创建一个CustomMath继承 NSObject 的类 执行一个 ➕ 方法 如果我们在 Swift 项目中使用 Object-C 代码的话建立一个桥接文件 Bridging-header.h，在桥接文件中#import &quot;CustomMath.h&quot;就能在 Swift 中调用 OC 代码了，但是Swift创建 Framework 是不允许使用桥接文件的(编译报错error: using bridging headers with framework targets is unsupported)，怎么办?! 第一种方法，按照文档中，为了让Swift文件访问Objective-C文件，我们应该在umbrella header，也就是TestUIKit.h中，暴露所需要的header。然后你就可以在Swift代码中轻松的使用CustomMath类了 第二种方法，如果你的Objective-C文件和接口并不想暴露可以采用modulemap。新建一个module.modulemap文件，内容如下： 这里输入的路径是module.modulemap文件所在的路径。（这里面可以申明多个模块） 然后，删除TestUIKit.h(umbrella header)中#import 的OC header。 把OCSource.h的权限改回默认的project。 然后在需要使用的 Swift 类中导入头文件一样 import CustomMath 就能在 Swift 代码中愉快的使用 OC 代码了。使用module.modulemap方法原文移步 引入cocopods代码- 我们用MBProgressHUD做例子，毕竟MBProgressHUD用法比较简单。使用 cocopods 下载，然后打开workspace。 虽然上面说可以使用module.modulemap方法可以使用OC代码了，但是我测试了一下即使把MBProgressHUD.h的完整路径写进去 编译时依然无法将module MBProgressHUD编译成功，可能我的操作方式不对。 后来只能另辟蹊径了：创建一个OC类OCBridgingHeader将MBProgressHUD等其他需要的使用的OC类都在这里导入头文件 在使用的地方 import OCBridgingHeader 最后还有一点，在合并真机和虚拟机库后，要将两者Modules文件夹中MaraTrackSDK.swiftmodule文件夹里所有的东西也合并，这样合并后的framework才真正的能在真机和虚拟机中使用！ Demo]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Today Extension中引用cocopods导入的第三方库]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9C%A8Today%20Extension%E4%B8%AD%E5%BC%95%E7%94%A8cocopods%E5%AF%BC%E5%85%A5%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[首先创建一个project在宿主App中创建插件难免会遇到需要公用类的情况，而使用的公用类中也许会用到由cocopods导入的第三方库，今天来创建一个demo记录一下 看大神的博客中讲到插件和宿主APP共享代码需要建立私有 framework，将公用的类在Target Membership选中framework项目。如图： 我建了一个TEKit和ContentView类，初始化两个label，使用SnapKit添加约束。OK，运行一下项目，报错。 1. 首先是公用的类undeclared。 2. 其次是公用类中引用的SnapKit找不到 `&lt;/pre&gt; 先从1开始解决(SnapKit相关代码先注释)，尝试1： &lt;pre&gt;`1. 首先在虚拟机环境编译framework `&lt;/pre&gt; 运行还是报同样的错。 尝试2： &lt;pre&gt;`1. 因为类默认状态是internal(在当前module中能被访问) 知道原因了就知道怎么修改了，将class的访问权限修改成open，运行。通过! 在真机运行时要注意，会提示Reason: image not found，这是因为项目没有绑定你的framework导致的，需要在Build Phases添加一个Copy files phase ok,再来看下第二个问题在framework和extension以及宿主App中引用cocopods时，在project中选中右侧Info-&gt;Configurations里面点开箭头你会发现宿主App右侧选中的是Pods-TodayExtensionDemo.debug, TodayExtension和TEKit右侧是none，选中和project名字一样的配置就可以了 其实还有一种更简单的方法是 将共享的类 在 Target Membership中都选中你需要引用的项目，不过这是一个非常不推荐的方法，因为编译时它会编译多次 Demo]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOOL / bool / Boolean / NSCFBoolean]]></title>
    <url>%2F2017%2F07%2F10%2FBOOL%20-%20bool%20-%20Boolean%20-%20NSCFBoolean%2F</url>
    <content type="text"><![CDATA[原文 Objective-C用BOOL来编码真值。它是signed char的typedef，并且用宏YES和NO来相应的表示真和假。 布尔值用于条件判断，比如if和while语句，来进行有条件的逻辑或者重复运行。当判断一个条件语句，数值0为“假”，而其他任何数值为“真”。因为NULL和nil被定义为0，所以对于这些不存在的数值的条件语句也被判定为“假”。 在Objective-C中，当遇到处理真值的参数，属性和实例变量时，使用类型BOOL。当分配字面值时，使用宏YES和NO。 延伸：signed char整数范围为-128到127,unsigned char整数范围为0到255。 新手程序员在判断条件句是总是使用一个等式运算符 if ([a isEqual:b] == YES) { ... } 这是没必要的。就像下面： static BOOL different (int a, int b) { return a - b; } if (different(11, 10) == YES) { printf (&quot;11 != 10\n&quot;); } else { printf (&quot;11 == 10\n&quot;); } print: 11 != 10 从算数运算中提取真值并不是一个好主意,它可能符合语法（毕竟，BOOL是一个signed char，因此它可以被视为数字），但是它在语意上完全说不通。所以，取而代之的方法是，使用==输出的结果，或者将数值通过!（或者!!）转换成布尔值。 ## [](#NSNumber-and-BOOL &quot;NSNumber and BOOL&quot;)NSNumber and BOOL &lt;pre&gt;`NSLog(@&quot;%@&quot;, [@(YES) class]); 输出的结果是：__NSCFBoolean 一直以来，我们都以为NSNumber将原始数封装为对象表示。其它任何由integer-和float-衍生出来的NSNumber对象都显示它的类为__NSCFNumber。这是为什么？ NSCFBoolean是NSNumber类簇中的一个私有的类。它是通往CFBooleanRef类型的桥梁，它被用来给Core Foundation的属性列表和集合封装布尔数值。CFBoolean定义了常量kCFBooleanTrue和kCFBooleanFalse。因为CFNumberRef和CFBooleanRef在Core Foundation中属于不同种类，这样是有道理的，它们在NSNumber被以不同的衔接类呈现。 表格是Objective-C中的所有真值类型和数值：]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github创建你自己的博客]]></title>
    <url>%2F2017%2F07%2F08%2Fhexo%2Bgithub%E5%88%9B%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[工作也几年了，技术也没有进步多少，现在究其原因多多少少会有对技术的学习没有一定的记录和整理这部分原因，这也是我现在建这个博客的初衷。之前也想着建一个博客，比如说新浪博客，后来觉得界面不太美感，写了两三篇就再没写下去。现在hexo+github可以免费建博客，而且不限流量还可以添加主题，又萌生了建博客的想法。 其实在网上有好多关于hexo+github的教程，我就不再啰嗦了。可以移步这里看我主要补充一下我在建博客的过程中遇到的问题及解决方法。 github repository 在github里Create repository时使用github昵称.github.io一定要和public profile里的Name保持一致，这是固定写法，否则即使把hexo搭建好了也无法打开有效页面。 Markdown加载本地图片 写博客的时候很多时候都需要插入图片来更直观的表现出来作者的意思，也让读者更容易理解和操作，我在写本地博客的时候在跟文章统计目录下新建一个images文件夹，在文章中使用 ![](images/image.JPG)可以很直接的在markdown编辑器里看到图片效果，但是这么做在你执行 hexo deploy之后，加载github昵称.github.io里的文章时图片并没有显示出来，这是由于hexo在生成静态页面的时候并没有拷贝图片到静态页面相同的目录下，所以我们需要另辟蹊径。在hexo的_config.yml同级目录下的source文件夹中添加images文件夹，我是以年份来归档图片使用图片时，图片的路径![](/images/2017/hexo_github_blog_image1.png)就可以了，如果需要添加文件地址同理简历一个document文件夹。]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Universal Links 通用链接]]></title>
    <url>%2F2017%2F07%2F06%2FUniversal%20Links%20%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[自 iOS9 就有了这么一个神奇的 Universal Links，通过识别HTTP链接启动APP 而不用再添加URL Schemes实现简单的程序间跳转，比如经常见的是在微信的web页中跳转到相应的APP。至此，由于产品需求需要实现在任何网页都支持跳转到APP才发掘这个功能，在写demo的过程中也遇到了一些坑 配置首先，我们需要在Xcode的Capabilities配置中打开Associated Domains项，设置我们需要跳转的域名条件，可以设置多个。如图: 除了在Xcode中设置关联的域名之外，还有更重要的一步是在SSL证书被认证的域名根目录下存放一个名为apple-app-site-association的JSON格式文件。如图: details中两个字段需要配置成我们需要的信息，appID H3F25LDX4E.com.association.demo,其中H3F25LDX4E是我们Team ID可以在这里获取后面的com.association.demo很显然就是自己项目的bundle id了。paths里设置要识别的路径列表，如果识别所有路径的话使用 “ * “ 实现代理 如果userActivity.activityType是NSUserActivityTypeBrowsingWeb类型的话，说明是走的通用链接，这时 webURL是有值的，之后在APP中将内容显示给用户即可。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态库和动态库]]></title>
    <url>%2F2017%2F07%2F05%2F%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93%20Static%20Library%2F</url>
    <content type="text"><![CDATA[补充： 我们知道静态库的目的是对功能的封装，静态库中的函数是要通过静态链接器跟工程源码链接在一起形成最终的可执行文件。而动态链接库的向我们的应用提供了一种调用外部代码的方式，使得我们的应用在链接的时候只需要“接入”动态链接库的地址而非源码，这样减小了可执行文件的体积。但是由于苹果的沙箱机制，iOS App无法直接调用除系统之外的沙箱外部的代码，所以我们在XCode中虽然创建的是动态库，实际上是静态库的效果。Framework帮我们将头文件、可执行文件、资源文件等封装在了一起，是苹果推荐的方式。 什么是静态库 Static Library所谓静态库或者说是 .a 文件，就是一系列从源码编译的目标文件的集合。它是源码的实现对应的二进制。在最后编译app的时候 .a 将被链接到最终的可执行文件中，之后每次都随着app 的可执行二进制文件一同加载，你不能控制加载的方式和时机。 什么是动态框架 Dynamic FrameworkFramework其实是一个bundle， 或者说是一个特殊的文件夹。系统的是存在于系统内部，而不会打包进app中。app启动是会检查所需要的动态框架是否已经加载。像UIKit之类的系统框架一般已经在内存中，不需要再次加载，这可以保证app启动速度。Framework是自包含的，你不需要关心头文件位置等。 Library vs FrameworkFramework有很多好处，比如它可以将资源文件（xib，image）包含在自己的bundle中，而Library不能包含，只能将这些文件单独拉进app的main bundle中才能使用，维护较困难。 动态框架加载到内存后不需要再次加载二次启动速度加快。 Cocoa Touch FrameworkiOS 8后苹果允许开发者有条件的创建和使用动态框架，这种框架叫Cocoa Touch Framework。 虽然同样是动态的，但是和系统的Framework不同，app中使用CTF在打包和提交app时会被放到app bundle中，运行在沙盒里，而不是系统中。也就是说不同的app使用了同样的Framework会被分别签名，打包和加载 CTF的推出为了解决两个问题： 一是为了ios8 之后的扩展开发 而是因为Swift在开源之前是不支持编译为静态库的。 包和依赖管理现在使用最广泛的应该是CocoaPods，它是一个ruby程序。 CocoaPods 的主要原理是框架的提供者通过编写合适的PodSpec 文件来提供框架的基本信息，包括仓库地址，需要编译的文件，依赖等 用户使用 Podfile 文件指定想要使用的框架，CocoaPods 会创建一个新的工程来管理这些框架和它们的依赖，并把所有这些框架编译到成一个静态的 libPod.a。然后新建一个 workspace 包含你原来的项目和这个新的框架项目，最后在原来的项目中使用这个libPods.a 因为现在Swfit的代码只能被编译为动态框架，所以使用的依赖中包含swift代码，又想使用CocoaPods来管理的话必须在Podfile中添加 user_framework!来编译Cocoa Touch Framework 创建框架API设计在 API 设计的时候，从原则上来说，我们一开始可以提供尽可能少的接口来完成必要的任务，这有助于在框架初期控制框架的复杂程度。 之后随着逐步的开发和框架使用场景的扩展，我们可以添加公共接口或者将原来的 internal 或者 private 接口标记为 public 供外界使用。另外需要注意方法名应该是动词或者动词短语开头，而属性名应该是名词 关于 API 的命名，Apple 官方给出了一个很详细的指南(Swift API Design Guidelines)，相信每个开发者的必读内容 更多]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
