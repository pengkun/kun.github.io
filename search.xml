<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gRPC]]></title>
    <url>%2F2019%2F07%2F02%2FgRPC%2F</url>
    <content type="text"><![CDATA[官方文档 Download the example####1. 在执行文档中的步骤时开始出现了这样的错误信息 git RPC failed; curl 18 transfer closed with outstanding read data remaining 原因：git缓存设置不够需要增大缓存配置 解决办法如下 git config http.postBuffer 524288000 git config https.postBuffer 524288000 ####2. 第一步问题解决后后面执行pod install时又出现 git error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 查了好久网友给的解决办法好多，最后结论是mac 自带的git可能不完整配置文件缺少一些有用信息，只需要重新下载git就能解决这个问题 brew install git 终端开始下载关联的库 等待ing运行demo 报错。。。 可运行Demo 3. 使用新的proto在.podspec文件中有自动将proto文件转换成对应的项目类文件 4. Run the serverFor this sample app, we need a gRPC server running on the local machine. gRPC Objective-C API supports creating gRPC clients but not gRPC servers. Therefore instead we build and run the C++ server in the same repository: 123$ cd examples/cpp/helloworld$ make$ ./greeter_server &amp;]]></content>
      <tags>
        <tag>-- iOS -- gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU 资源消耗原因和解决方案（转载)]]></title>
    <url>%2F2019%2F06%2F26%2FCPU-%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原文传送门 对象创建对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。 尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 对象调整对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 对象销毁对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 布局计算视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。 不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。 AutolayoutAutolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：http://pilky.me/36/。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。 文本计算如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。 如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 文本渲染屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 图片的解码当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 图像的绘制图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）： 1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS12 保存生成的二维码图片到相册失败]]></title>
    <url>%2F2018%2F11%2F06%2FUIimage-CGImage-CIImage%2F</url>
    <content type="text"><![CDATA[手机系统最近升级到iOS 12后，原项目中，保存生成的二维码图片到系统相册失败。 1func UIImageWriteToSavedPhotosAlbum(_ image: UIImage, _ completionTarget: Any?, _ completionSelector: Selector?, _ contextInfo: UnsafeMutableRawPointer?) 以上代码只是介绍需要的参数是image，接收的参数是UIImage类型，没有说明image需要满足的条件 在虚拟机中报的错误是： Error Domain=ALAssetsLibraryErrorDomain Code=-3300 “写入失败” UserInfo={NSUnderlyingError=0x6000008d96b0 {Error Domain=ALAssetsLibraryErrorDomain Code=-3300 “写入失败” UserInfo={NSUnderlyingError=0x6000008d95f0 {Error Domain=ALAssetsLibraryErrorDomain Code=-3300 “写入失败” UserInfo={NSUnderlyingError=0x6000008d8d20 {Error Domain=PersistentURLTranslator Code=10 “(null)”}, NSLocalizedDescription=写入失败, NSLocalizedFailureReason=写入此资产时出现问题，因为写入无效。}}, NSLocalizedDescription=写入失败, NSLocalizedFailureReason=写入此资产时出现问题，因为写入无效。}}, NSLocalizedDescription=写入失败, NSLocalizedFailureReason=写入此资产时出现问题，因为写入无效。} 一头雾水，以为没有权限，再三检查了确认 在真机中没有报错，但是通过控制台打印image的data数据时，却是nil po image?.pngData() nil 应该是跟不能转成data数据有关了，通过检查发现，image的cgImage是空而ciImage有值。 生成的二维码是通过CIFilter生成 The CIFilter class produces a CIImage object as output 官方文档说明CIFilter生成CIImage对象，而CIImage只是CoreImage过滤处理或生成的图像的表示，而不是真正的图片数据，所以不能生成data，而CGImage才是图片数据，所以只需要将保存的image保证cgImage值不为空就能保存成功。 附上代码a. 生成二维码的代码 123456789101112131415161718192021222324252627282930313233343536373839// String的扩展，出现问题的情况是 中间的图标为空时 func ext_createQRImage(_ qrImageName: String = "") -&gt; UIImage? &#123; guard !self.isEmpty else &#123; return nil &#125; let stringData = self.data(using: .utf8, allowLossyConversion: false) // 创建一个二维码的滤镜 let qrFilter = CIFilter(name: "CIQRCodeGenerator") qrFilter?.setValue(stringData, forKey: "inputMessage") qrFilter?.setValue("H", forKey: "inputCorrectionLevel") let qrCIImage = qrFilter?.outputImage // 创建一个颜色滤镜,黑白色 let colorFilter = CIFilter(name: "CIFalseColor") colorFilter?.setDefaults() colorFilter?.setValue(qrCIImage, forKey: "inputImage") colorFilter?.setValue(CIColor(red: 0, green: 0, blue: 0), forKey: "inputColor0") colorFilter?.setValue(CIColor(red: 1, green: 1, blue: 1), forKey: "inputColor1") // 返回二维码image var codeImage: UIImage? if let outImage = colorFilter?.outputImage &#123; codeImage = UIImage(ciImage: outImage.transformed(by: CGAffineTransform(scaleX: 10, y: 10))) &#125; // 通常,二维码都是定制的,中间都会放想要表达意思的图片 if let iconImage = UIImage(named: qrImageName), let codeImg = codeImage &#123; let rect = CGRect(x: 0, y: 0, width: codeImg.size.width, height: codeImg.size.height) UIGraphicsBeginImageContext(rect.size) codeImg.draw(in: rect) let avatarSize = CGSize(width: rect.size.width * 0.25, height: rect.size.height * 0.25) let x = (rect.width - avatarSize.width) * 0.5 let y = (rect.height - avatarSize.height) * 0.5 iconImage.draw(in: CGRect(x: x, y: y, width: avatarSize.width, height: avatarSize.height)) let resultImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return resultImage &#125; return codeImage &#125; b. 生成UIImage包含CGImage的代码 12345678910111213141516extension UIImage &#123; /// 比系统的 多了步没有就用CI转换 func ext_getCGImage() -&gt; CGImage? &#123; return cgImage ?? ext_CIImageToCGImage() &#125; func ext_CIImageToCGImage(ciContext: CIContext = CIContext()) -&gt; CGImage? &#123; guard let ciImg = ciImage else &#123; return nil &#125; return ciContext.createCGImage(ciImg, from: ciImg.extent) &#125;&#125;let qrImage = "二维码". ext_createQRImage()let cgImage = qrImage. ext_getCGImage()let saveImage = UIImage(cgImage: cgImage!)UIImageWriteToSavedPhotosAlbum(saveImage, nil, nil, nil)// 保存成功]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode10适配]]></title>
    <url>%2F2018%2F10%2F24%2Fxcode10%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[最近从苹果开发者网站下载了最新的xcode10并同时安装了9和10版本，我们项目是用swift语言开发，所以面对swift4.2版本报了不少错误 1. 第三方库需要升级修改升级第三方的版本号 检查当前编译器环境xcodebuild -version 切换使用Xcode10的编译器，确保是Xcode10sudo xcode-select -switch /Applications/Xcode10.app 重新编译第三方库carthage update –platform iOS 2. 报info.plist文件重复的错误解决方法1. 删除掉第三方库当中的infp.plist 解决方法2. Xcode - Project Setting - Build System - Legacy Build System 3. 报缺少动态库libstdc++.*的错误libstdc++.tbd和libstdc++6.0.9.tbd在xcode10中已经被废弃 解决方法1. 删除本地ibstdc++.tbd和libstdc++6.0.9.tbd，并且升级第三方库 解决方法2. 将xcode9中的ibstdc++.tbd和libstdc++6.0.9.tbd拷贝到xcode10]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Carthage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用crontab给scrapy的爬虫程序添加定时任务]]></title>
    <url>%2F2018%2F09%2F21%2Fcrontab%2F</url>
    <content type="text"><![CDATA[1. 编写执行任务的cron.sh,并输出日志12345678#! /bin/shexport PATH=$PATH:/Library/Frameworks/Python.framework/Versions/3.6/bin# 爬虫文件地址cd /Users/xxx/Documents/Code/Spider/News/newsnohup scrapy crawl news --nolog &gt;&gt; news.log 2&gt;&amp;1 &amp; 2. 添加定时任务123sudo crontab -e */1 * * * * sh /Users/pengkun/Documents/SourceCode/Spider/cron.sh 1234567每五分钟执行 */5 * * * *每小时执行 0 * * * *每2小时执行 0 */2 * * *每天执行 0 0 * * *每周执行 0 0 * * 0每月执行 0 0 1 * *每年执行 0 0 1 1 * 查看定时任务sudo crontab -l 3. 遇到的问题 代码是在PyCharm IDE里编写的，依赖的库之前用pip3 install过一次，在PyCharm里也install一次，直接命令行运行scrapy是没有问题，当用crontab开启定时任务时，一直报错 module XX 找不到，具体原因不太清楚，把所有用pip3 安装过的插件移除掉重新安装 就没有问题了]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用scrapy爬虫]]></title>
    <url>%2F2018%2F08%2F21%2Fpython-scrapy%2F</url>
    <content type="text"><![CDATA[1、安装wheel pip install wheel 2、安装lxml https://pypi.python.org/pypi/lxml/4.1.0 3、安装pyopenssl https://pypi.python.org/pypi/pyOpenSSL/17.5.0 4、安装Twisted https://www.lfd.uci.edu/~gohlke/pythonlibs/ 5、安装pywin32 https://sourceforge.net/projects/pywin32/files/ 6、安装scrapy pip install scrapy 创建工程 1scrapy startproject Spider 创建爬虫程序 12cd Spiderscrapy genspider meiju meijutt.com 执行爬虫 1scrapy crawl meiju --nolog post请求注释 start_urls，重写start_requests方法，request的callback回调到parse方法，这样我们就可以继续解析出我们想要的内容了 123456789def start_requests(self): yield scrapy.FormRequest( url='https://www.chainfor.com/home/list/news/data.do?', formdata=&#123; 'pageNo': '1', 'device_type': '0' &#125;, callback=self.parse ) 新闻先抓取列表链接，再抓取内容如果抓取新闻网站的时候，我们总是会遇到第一页面总是列表，还要再通过列表的链接抓取内容。我们只需要在parse函数里通过抓取的链接进行request请求，同样适用callback 指向自定义回调函数就可以。 12345678910111213141516171819202122def parse(self, response): list = [新闻列表链接] for i in range(len(list)): url = list[i] scrapy.Request(url, callback=self.parse_dir_contents) passdef parse_dir_contents(self, response): item = Item() item["name"] = response.xpath("//div[@class='m-infor rt']/div[@class='m-i-article']/h1/text()").extract()[0].strip() item["time"] = self.validTime[idx] item["img"] = self.validImgs[idx] content = response.xpath("//div[@class='m-infor rt']/div[@class='m-i-article']/div[@class='m-i-bd']/*") newsContent = '' for p in content: temp = etree.tostring(p, encoding='utf-8').decode('utf-8') newsContent += temp item["content"] = newsContent yield item pass 获取内容标签里的所有标签 xpath语句最后 ‘/*’，标签对象转字符串时，需要解码 网上查得给自定义回调函数添加其他参数时，代码： scrapy.Request(url, callback=lambda response, idx=i: self.parse_dir_contents(response, idx)) def parse_dir_contents(self, response, idx):]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑步轨迹回放]]></title>
    <url>%2F2017%2F12%2F05%2F%E8%B7%91%E6%AD%A5%E8%BD%A8%E8%BF%B9%E5%9B%9E%E6%94%BE%2F</url>
    <content type="text"><![CDATA[高德地图跑步轨迹展示的代码在高德官方的3D地图示例中RunningLineViewController类中已经有很好的示例代码，就不再赘述了 下载AMap_iOS_Demo。这篇主要记录下实现轨迹回放的功能，当然这个方法对于所有地图的轨迹回放都是可用的。 实现回放准备条件： 坐标数组、坐标对应的颜色数组 渐变线 动画 坐标转换，计算path-var coordinateArray: [CLLocationCoordinate2D] = [] // 跑步记录的坐标集合coordinateArray 转换成视图上的坐标用于创建layer轨迹的CGMutablePath对象 1234567891011fileprivate func pointsForCoordinates() -&gt;[CGPoint] &#123; var points: [CGPoint] = [] for coordinate in self.coordinateArray &#123; guard let map_view = self.mapView else &#123; return [] &#125; let point = map_view.convert(coordinate, toPointTo: map_view) points.append(point) &#125; return points&#125;let path = CGMutablePath()path.addLines(between: points) 渐变线-自定义CustomGradientLayer，重写draw(in ctx: CGContext)方法。这里要用到Quartz2D的知识点，我在简书里找到了关于Quartz2D讲解可以学习一下。这里用到了路径、颜色与颜色空间、渐变相关技术。颜色的处理方式采用的是高德demo里面的算法，只是修改了一下偏冷色和偏暖色的值。(Swift中苹果对CGMutablePath进行了重构，CGMutablePath被定义为了类, 内存这一块就不用我们手动管理了，👍👍👍) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func add(points: [CGPoint], colors: [UIColor]) &#123; self._points = points self._colors = colors&#125;override func draw(in ctx: CGContext) &#123; var pcolor: UIColor? var ccolor: UIColor? for i in 0..&lt;self._points.count &#123; let point: CGPoint = self._points[i] let path: CGMutablePath = CGMutablePath() ccolor = self._colors[i] if i == 0 &#123; path.move(to: CGPoint(x: point.x, y: point.y), transform: .identity) &#125; else &#123; let prevPoint: CGPoint = self._points[i - 1] path.addLine(to: CGPoint(x: point.x, y: point.y), transform: .identity) var pc_r: CGFloat = 0 var pc_g: CGFloat = 0 var pc_b: CGFloat = 0 var pc_a: CGFloat = 0 var cc_r: CGFloat = 0 var cc_g: CGFloat = 0 var cc_b: CGFloat = 0 var cc_a: CGFloat = 0 pcolor?.getRed(&amp;pc_r, green: &amp;pc_g, blue: &amp;pc_b, alpha: &amp;pc_a) ccolor?.getRed(&amp;cc_r, green: &amp;cc_g, blue: &amp;cc_b, alpha: &amp;cc_a) let gradientColors: [CGFloat] = [pc_r, pc_g, pc_b, pc_a, cc_r, cc_g, cc_b, cc_a] let gradientLocation: [CGFloat] = [0, 1] ctx.saveGState() let lineWidth: CGFloat = ctx.convertToUserSpace(CGSize(width: 5, height: 5)).width let pathToFill: CGPath = path.copy(strokingWithWidth: lineWidth, lineCap: .round, lineJoin: .round, miterLimit: 10, transform: .identity) ctx.addPath(pathToFill) ctx.clip() let colorSpace: CGColorSpace = CGColorSpaceCreateDeviceRGB() if let gradient = CGGradient(colorSpace: colorSpace, colorComponents: gradientColors, locations: gradientLocation, count: 2) &#123; let gradientStart: CGPoint = prevPoint let gradientEnd: CGPoint = point ctx.drawLinearGradient(gradient, start: gradientStart, end: gradientEnd, options: .drawsAfterEndLocation) &#125; ctx.restoreGState() &#125; pcolor = ccolor &#125;&#125; 在gradientLayer调用func add(points: [CGPoint], colors: [UIColor]) 函数后调用自身的setNeedsDisplay()方法重绘。我们还需要在Replaying中给layer添加一个蒙板mask(这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。mask图层定义了父图层的部分可见区域) 12345678fileprivate func initShapeLayer() &#123; self.shapeLayer.lineWidth = 5 self.shapeLayer.strokeColor = UIColor.clear.cgColor self.shapeLayer.fillColor = UIColor.clear.cgColor self.shapeLayer.lineJoin = kCALineCapRound&#125;self.shapeLayer.path = pathself.gradientLayer.mask = self.shapeLayer ok，渐变线出来了 动画动画12345678910let shapeLayerAnimation = self.constructShapeLayerAnimation()self.shapeLayer.add(shapeLayerAnimation, forKey: "shape")fileprivate func constructShapeLayerAnimation() -&gt; CAAnimation &#123; let annimation = CABasicAnimation(keyPath: "strokeEnd") annimation.duration = self.duration annimation.fromValue = 0.0 annimation.toValue = 1.0 return annimation&#125; 下载]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Running</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑步过程中播报跑步数据，实现长时间后台保活]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%97%B6%E9%97%B4%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%B4%BB%EF%BC%8C%E8%B7%91%E6%AD%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%92%AD%E6%8A%A5%E8%B7%91%E6%AD%A5%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[编写跑步app的时候音频播放总是面临着三个问题： 如何保证app长时间后台运行 如何在播报语音(几十个mp3文件)时保障连贯性 利用AudioSession如何处理好与其他同类型app播放的冲突 当时经过对竞品app的研究发现，实现长时间后台运行采用其中一种方式：持续播放无声音乐对于第二个问题，我们一直在试错： 第一种方式将即将播放的语音文件名存入数组中，轮询播放数组里文件 第二种方式将即将播放的语音提前初始化AudioPlayer缓存到内存中，轮询播放 （这两种方式呢都没有保障播放的连贯性，而且如果用户手机里安装了同样采用此种做法的app的话，AudioSession设置比较复杂，而且播放中出现‘抢夺播放’导致播放卡顿的问题肯定会存在。） 第三种方式利用AVMutableComposition合并所有即将播放的文件成一个文件，单独播放这一个文件既解决连贯性也解决了抢夺播放的问题 程序保活AudioSession的设置： 播放无音音乐实现程序后台持续运行，category: AVAudioSessionCategoryPlayback。 需要考虑不要影响其他app的音频播放，比如音乐类软件, options: . mixWithOthers(混响)调用AudioPlayer播放前先设置AudioSession 123456do &#123; try self.audioSession.setCategory(AVAudioSessionCategoryPlayback, with: .mixWithOthers) try self.audioSession.setActive(true)&#125; catch let error &#123; debugPrint("\(type(of:self)):\(error)")&#125; 1. 场景123456// 背景音乐enum AudioPlayScene &#123; case normal // 前台播放，后台不播放，为了用户在使用时可以任意修改音量 case none // 前后台都不播放 case run // 前后台都需要播放，用于跑步过程中&#125; 根据自己的需求设置 AudioManager.shared.audioPlayScene 2. 启动保活实现保活需要在AppDelegate中实现必要的两个回调函数 123456789101112func applicationDidEnterBackground(_ application: UIApplication) &#123; // 不在跑步页面才需要关闭 if AudioManager.shared.audioPlayScene != .run &#123; AudioManager.shared.openBackgroundAudioAutoPlay = false &#125;&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; AudioManager.shared.openBackgroundAudioAutoPlay = true&#125; 播报AudioModel 对数据的处理和封装MergeAudioTool 对AudioModel的数据进行合并 123456func play() &#123; var audioText = [[String: [String]]]() audioText.append(["altitude": ["3","2","1","relax","3","2","1","relax"]]) guard let audioModel = AudioModel(res: audioText) else&#123;return&#125; AudioManager.shared.playWithModel(res: audioModel)&#125; Demo]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Running</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS整体竖屏,个别页面横屏遇到的坑及解决办法]]></title>
    <url>%2F2017%2F11%2F15%2FiOS%E6%95%B4%E4%BD%93%E7%AB%96%E5%B1%8F%2C%E4%B8%AA%E5%88%AB%E9%A1%B5%E9%9D%A2%E6%A8%AA%E5%B1%8F%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[iOS竖屏状态下present一个横屏的viewController(继承BaseViewController)出现bug，每次app第一次启动后，会出现如图1中的现象，本应该横屏全屏的界面，结果成了竖屏只有上半边的情况，下半边全黑，再次进入这个页面就不会再出现。 图1 这时我在【General】【Device Orientation】中只选择了【Portrait】 在需要横屏的ViewController中添加代码： 1234567891011override var shouldAutorotate: Bool { return false }override var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .landscapeRight } override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation { return .landscapeRight } 解决办法在【General】【Device Orientation】中选择了【Portrait】和【Landscape Right】，只在AppDelegate中设置 123456789var allowRotation: Bool = false //是否允许转向func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask { if self.allowRotation { return .landscapeRight } else { return .portrait } } 然后在需要设置横屏的Controller 的 viewDidLoad 函数中设置 123if let appDelegate = UIApplication.shared.delegate as? AppDelegate { appDelegate.allowRotation = true } 在点击返回按钮时重新设置上面的值 123if let appDelegate = UIApplication.shared.delegate as? AppDelegate { appDelegate.allowRotation = false }]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iWatch-page]]></title>
    <url>%2F2017%2F09%2F30%2FiWatch-page%2F</url>
    <content type="text"><![CDATA[今天整理一下在 Apple Watch 上实现 Page 和 圆形进度条两种效果，刚开始做的时候也很头大，也没见有多少人写 特别是 关于 圆形进度条效果 的博客。其实这两种效果实现起来超乎想象的简单。 Page实现Page效果有两种方式： 第一种 在storyboard上连线 第一个controller连第二个controller选择next page第二个controller连第三个controller选择next page他们之间的返回，SB也已经为我们做好了 第二种 使用代码ExtensionDelegate func applicationDidFinishLaunching() { // Perform any final initialization of your application. WKInterfaceController.reloadRootControllers(withNames: [&quot;Controller1&quot;, &quot;Controller2&quot;, &quot;Controller3&quot;], contexts: nil) } `&lt;/pre&gt; 如果说我想让Page中的第一个controller的按钮操作影响第二个controller，我目前找到的方法是 notification ## [](#圆形进度条 &quot;圆形进度条&quot;)圆形进度条 当时为了这个东西也是翻遍的了 度娘 后来还是在stackflow上找到一个答案。 `WKImageAnimatable` 协议的有一个函数： &lt;pre&gt;`// Play a subset of images for a certain number of times. 0 means repeat until stop. public func startAnimatingWithImages(in imageRange: NSRange, duration: TimeInterval, repeatCount: Int) 类似 UIImageView 的 startAnimating() 方法，看到这里明眼人就明白了，watch上实现的进度条是一张图片，进度的改变的过程就是一组帧动画你要做的就是算好执行到哪一帧 实现进度条用到的图片已经有大大们制作好了工具传送门]]></content>
      <tags>
        <tag>Apple Watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift与Object-C混编创建Framework，并引用cocopods（OC代码库）]]></title>
    <url>%2F2017%2F07%2F31%2FSwift%E4%B8%8EObject-C%E6%B7%B7%E7%BC%96%E5%88%9B%E5%BB%BAFramework%EF%BC%8C%E5%B9%B6%E5%BC%95%E7%94%A8cocopods%EF%BC%88OC%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自己在创建Framework的过程中踩了很多坑，特别是我们有一部分关键代码是 C++ 写的而且还需要引用第三方 Object-C 库就更坑了，把跳坑的方法写在这里。 创建Framework-Xcode-&gt;File-&gt;New-&gt;Project-&gt;Cocoa Touch Framework我这里命名 TestUIKit Swift创建 Framework 文件目录要求代码放进Sources文件夹，我们需要修改一下文件目录，将项目中的 TestUIKit实体文件夹改名成 Sources，前后对比图： 与此同时我们还需要在项目右侧的TARGETS-&gt;Build Setting里面修改Info.plist路径地址Sources/Info.plist 创建 Object-C 类-创建一个CustomMath继承 NSObject 的类 执行一个 ➕ 方法 如果我们在 Swift 项目中使用 Object-C 代码的话建立一个桥接文件 Bridging-header.h，在桥接文件中#import &quot;CustomMath.h&quot;就能在 Swift 中调用 OC 代码了，但是Swift创建 Framework 是不允许使用桥接文件的(编译报错error: using bridging headers with framework targets is unsupported)，怎么办?! 第一种方法，按照文档中，为了让Swift文件访问Objective-C文件，我们应该在umbrella header，也就是TestUIKit.h中，暴露所需要的header。然后你就可以在Swift代码中轻松的使用CustomMath类了 第二种方法，如果你的Objective-C文件和接口并不想暴露可以采用modulemap。新建一个module.modulemap文件，内容如下： 这里输入的路径是module.modulemap文件所在的路径。（这里面可以申明多个模块） 然后，删除TestUIKit.h(umbrella header)中#import 的OC header。 把OCSource.h的权限改回默认的project。 然后在需要使用的 Swift 类中导入头文件一样 import CustomMath 就能在 Swift 代码中愉快的使用 OC 代码了。使用module.modulemap方法原文移步 引入cocopods代码- 我们用MBProgressHUD做例子，毕竟MBProgressHUD用法比较简单。使用 cocopods 下载，然后打开workspace。 虽然上面说可以使用module.modulemap方法可以使用OC代码了，但是我测试了一下即使把MBProgressHUD.h的完整路径写进去 编译时依然无法将module MBProgressHUD编译成功，可能我的操作方式不对。 后来只能另辟蹊径了：创建一个OC类OCBridgingHeader将MBProgressHUD等其他需要的使用的OC类都在这里导入头文件 在使用的地方 import OCBridgingHeader 最后还有一点，在合并真机和虚拟机库后，要将两者Modules文件夹中MaraTrackSDK.swiftmodule文件夹里所有的东西也合并，这样合并后的framework才真正的能在真机和虚拟机中使用！ Demo]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Today Extension中引用cocopods导入的第三方库]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%9C%A8Today%20Extension%E4%B8%AD%E5%BC%95%E7%94%A8cocopods%E5%AF%BC%E5%85%A5%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[首先创建一个project在宿主App中创建插件难免会遇到需要公用类的情况，而使用的公用类中也许会用到由cocopods导入的第三方库，今天来创建一个demo记录一下 看大神的博客中讲到插件和宿主APP共享代码需要建立私有 framework，将公用的类在Target Membership选中framework项目。如图： 我建了一个TEKit和ContentView类，初始化两个label，使用SnapKit添加约束。OK，运行一下项目，报错。 1. 首先是公用的类undeclared。 2. 其次是公用类中引用的SnapKit找不到 `&lt;/pre&gt; 先从1开始解决(SnapKit相关代码先注释)，尝试1： &lt;pre&gt;`1. 首先在虚拟机环境编译framework `&lt;/pre&gt; 运行还是报同样的错。 尝试2： &lt;pre&gt;`1. 因为类默认状态是internal(在当前module中能被访问) 知道原因了就知道怎么修改了，将class的访问权限修改成open，运行。通过! 在真机运行时要注意，会提示Reason: image not found，这是因为项目没有绑定你的framework导致的，需要在Build Phases添加一个Copy files phase ok,再来看下第二个问题在framework和extension以及宿主App中引用cocopods时，在project中选中右侧Info-&gt;Configurations里面点开箭头你会发现宿主App右侧选中的是Pods-TodayExtensionDemo.debug, TodayExtension和TEKit右侧是none，选中和project名字一样的配置就可以了 其实还有一种更简单的方法是 将共享的类 在 Target Membership中都选中你需要引用的项目，不过这是一个非常不推荐的方法，因为编译时它会编译多次 Demo]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOOL / bool / Boolean / NSCFBoolean]]></title>
    <url>%2F2017%2F07%2F10%2FBOOL%20-%20bool%20-%20Boolean%20-%20NSCFBoolean%2F</url>
    <content type="text"><![CDATA[原文 Objective-C用BOOL来编码真值。它是signed char的typedef，并且用宏YES和NO来相应的表示真和假。 布尔值用于条件判断，比如if和while语句，来进行有条件的逻辑或者重复运行。当判断一个条件语句，数值0为“假”，而其他任何数值为“真”。因为NULL和nil被定义为0，所以对于这些不存在的数值的条件语句也被判定为“假”。 在Objective-C中，当遇到处理真值的参数，属性和实例变量时，使用类型BOOL。当分配字面值时，使用宏YES和NO。 延伸：signed char整数范围为-128到127,unsigned char整数范围为0到255。 新手程序员在判断条件句是总是使用一个等式运算符 if ([a isEqual:b] == YES) { ... } 这是没必要的。就像下面： static BOOL different (int a, int b) { return a - b; } if (different(11, 10) == YES) { printf (&quot;11 != 10\n&quot;); } else { printf (&quot;11 == 10\n&quot;); } print: 11 != 10 从算数运算中提取真值并不是一个好主意,它可能符合语法（毕竟，BOOL是一个signed char，因此它可以被视为数字），但是它在语意上完全说不通。所以，取而代之的方法是，使用==输出的结果，或者将数值通过!（或者!!）转换成布尔值。 ## [](#NSNumber-and-BOOL &quot;NSNumber and BOOL&quot;)NSNumber and BOOL &lt;pre&gt;`NSLog(@&quot;%@&quot;, [@(YES) class]); 输出的结果是：__NSCFBoolean 一直以来，我们都以为NSNumber将原始数封装为对象表示。其它任何由integer-和float-衍生出来的NSNumber对象都显示它的类为__NSCFNumber。这是为什么？ NSCFBoolean是NSNumber类簇中的一个私有的类。它是通往CFBooleanRef类型的桥梁，它被用来给Core Foundation的属性列表和集合封装布尔数值。CFBoolean定义了常量kCFBooleanTrue和kCFBooleanFalse。因为CFNumberRef和CFBooleanRef在Core Foundation中属于不同种类，这样是有道理的，它们在NSNumber被以不同的衔接类呈现。 表格是Objective-C中的所有真值类型和数值：]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github创建你自己的博客]]></title>
    <url>%2F2017%2F07%2F08%2Fhexo%2Bgithub%E5%88%9B%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[工作也几年了，技术也没有进步多少，现在究其原因多多少少会有对技术的学习没有一定的记录和整理这部分原因，这也是我现在建这个博客的初衷。之前也想着建一个博客，比如说新浪博客，后来觉得界面不太美感，写了两三篇就再没写下去。现在hexo+github可以免费建博客，而且不限流量还可以添加主题，又萌生了建博客的想法。 其实在网上有好多关于hexo+github的教程，我就不再啰嗦了。可以移步这里看我主要补充一下我在建博客的过程中遇到的问题及解决方法。 github repository 在github里Create repository时使用github昵称.github.io一定要和public profile里的Name保持一致，这是固定写法，否则即使把hexo搭建好了也无法打开有效页面。 Markdown加载本地图片 写博客的时候很多时候都需要插入图片来更直观的表现出来作者的意思，也让读者更容易理解和操作，我在写本地博客的时候在跟文章统计目录下新建一个images文件夹，在文章中使用 ![](images/image.JPG)可以很直接的在markdown编辑器里看到图片效果，但是这么做在你执行 hexo deploy之后，加载github昵称.github.io里的文章时图片并没有显示出来，这是由于hexo在生成静态页面的时候并没有拷贝图片到静态页面相同的目录下，所以我们需要另辟蹊径。在hexo的_config.yml同级目录下的source文件夹中添加images文件夹，我是以年份来归档图片使用图片时，图片的路径![](/images/2017/hexo_github_blog_image1.png)就可以了，如果需要添加文件地址同理简历一个document文件夹。]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Universal Links 通用链接]]></title>
    <url>%2F2017%2F07%2F06%2FUniversal%20Links%20%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[自 iOS9 就有了这么一个神奇的 Universal Links，通过识别HTTP链接启动APP 而不用再添加URL Schemes实现简单的程序间跳转，比如经常见的是在微信的web页中跳转到相应的APP。至此，由于产品需求需要实现在任何网页都支持跳转到APP才发掘这个功能，在写demo的过程中也遇到了一些坑 配置首先，我们需要在Xcode的Capabilities配置中打开Associated Domains项，设置我们需要跳转的域名条件，可以设置多个。如图: 除了在Xcode中设置关联的域名之外，还有更重要的一步是在SSL证书被认证的域名根目录下存放一个名为apple-app-site-association的JSON格式文件。如图: details中两个字段需要配置成我们需要的信息，appID H3F25LDX4E.com.association.demo,其中H3F25LDX4E是我们Team ID可以在这里获取后面的com.association.demo很显然就是自己项目的bundle id了。paths里设置要识别的路径列表，如果识别所有路径的话使用 “ * “ 实现代理 如果userActivity.activityType是NSUserActivityTypeBrowsingWeb类型的话，说明是走的通用链接，这时 webURL是有值的，之后在APP中将内容显示给用户即可。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态库和动态库]]></title>
    <url>%2F2017%2F07%2F05%2F%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93%20Static%20Library%2F</url>
    <content type="text"><![CDATA[补充： 我们知道静态库的目的是对功能的封装，静态库中的函数是要通过静态链接器跟工程源码链接在一起形成最终的可执行文件。而动态链接库的向我们的应用提供了一种调用外部代码的方式，使得我们的应用在链接的时候只需要“接入”动态链接库的地址而非源码，这样减小了可执行文件的体积。但是由于苹果的沙箱机制，iOS App无法直接调用除系统之外的沙箱外部的代码，所以我们在XCode中虽然创建的是动态库，实际上是静态库的效果。Framework帮我们将头文件、可执行文件、资源文件等封装在了一起，是苹果推荐的方式。 什么是静态库 Static Library所谓静态库或者说是 .a 文件，就是一系列从源码编译的目标文件的集合。它是源码的实现对应的二进制。在最后编译app的时候 .a 将被链接到最终的可执行文件中，之后每次都随着app 的可执行二进制文件一同加载，你不能控制加载的方式和时机。 什么是动态框架 Dynamic FrameworkFramework其实是一个bundle， 或者说是一个特殊的文件夹。系统的是存在于系统内部，而不会打包进app中。app启动是会检查所需要的动态框架是否已经加载。像UIKit之类的系统框架一般已经在内存中，不需要再次加载，这可以保证app启动速度。Framework是自包含的，你不需要关心头文件位置等。 Library vs FrameworkFramework有很多好处，比如它可以将资源文件（xib，image）包含在自己的bundle中，而Library不能包含，只能将这些文件单独拉进app的main bundle中才能使用，维护较困难。 动态框架加载到内存后不需要再次加载二次启动速度加快。 Cocoa Touch FrameworkiOS 8后苹果允许开发者有条件的创建和使用动态框架，这种框架叫Cocoa Touch Framework。 虽然同样是动态的，但是和系统的Framework不同，app中使用CTF在打包和提交app时会被放到app bundle中，运行在沙盒里，而不是系统中。也就是说不同的app使用了同样的Framework会被分别签名，打包和加载 CTF的推出为了解决两个问题： 一是为了ios8 之后的扩展开发 而是因为Swift在开源之前是不支持编译为静态库的。 包和依赖管理现在使用最广泛的应该是CocoaPods，它是一个ruby程序。 CocoaPods 的主要原理是框架的提供者通过编写合适的PodSpec 文件来提供框架的基本信息，包括仓库地址，需要编译的文件，依赖等 用户使用 Podfile 文件指定想要使用的框架，CocoaPods 会创建一个新的工程来管理这些框架和它们的依赖，并把所有这些框架编译到成一个静态的 libPod.a。然后新建一个 workspace 包含你原来的项目和这个新的框架项目，最后在原来的项目中使用这个libPods.a 因为现在Swfit的代码只能被编译为动态框架，所以使用的依赖中包含swift代码，又想使用CocoaPods来管理的话必须在Podfile中添加 user_framework!来编译Cocoa Touch Framework 创建框架API设计在 API 设计的时候，从原则上来说，我们一开始可以提供尽可能少的接口来完成必要的任务，这有助于在框架初期控制框架的复杂程度。 之后随着逐步的开发和框架使用场景的扩展，我们可以添加公共接口或者将原来的 internal 或者 private 接口标记为 public 供外界使用。另外需要注意方法名应该是动词或者动词短语开头，而属性名应该是名词 关于 API 的命名，Apple 官方给出了一个很详细的指南(Swift API Design Guidelines)，相信每个开发者的必读内容 更多]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
